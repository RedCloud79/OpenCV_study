# 일반 영상을 그림체로 변환

> 1. 영상의 크기를 구하기 w, h
> 2. 영상을 열고 캡쳐하기
> 3. 영상에 효과를 주기
> 4. 영상 닫기

* 영상의 회전 변환 - Rotation transformation
  * 회전 변환은 영상을 특정 각도만큼 회전 시키는 변환이다.
  * affine 행렬을 생성하고, affwrap 함수를 이용해서 간단히 회전 할 수 있다.
    * aff = np.array([[math.cos(rad), math.sin(rad), 0],   
                [-math.sin(rad), math.cos(rad), 0]], dtype=np.float32)   
      dst = cv2.warpAffine(src, aff, (0, 0))
  * 영상의 중앙 기준 회전 ( cv2.getRotationMatrix2D )
    * cv2.getRotationMatrix2D(center, angle, scale) -> retval
    * 

* 

```python
import cv2
import time
import random
import imageio

# first check
cap = cv2.VideoCapture('muyaho.mp4')

# muyaho video start
cap.set(1, 900)

w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))


fourcc = cv2.VideoWriter_fourcc('m','p','4','v')
out = cv2.VideoWriter('output_1.mp4', fourcc, cap.get(cv2.CAP_PROP_FPS)/2, (w,h))

# second check
while cap.isOpened():
    # false to ret is finished video
    ret, img = cap.read()
    if not ret:
        break
    
    # effective video
    if random.random() > 0.9:
        theta = random.randint(-3, 3)
        x, y = random.randint(-10, 10), random.randint(-10, 10)

        # imgs are rotated
        M = cv2.getRotationMatrix2D(center = (w//2, h//2), angle=theta, scale=1.0)
        M[0, 2] += x
        M[1, 2] += y

        # affine transformation
        img = cv2.warpAffine(img, M, (w, h))

    img = cv2.GaussianBlur(img, ksize=(9,9), sigmaX=0)

    # pencil sketch effect
    # sigma_s = 0~200, sigma_r = 0 to 1 default : 0.07
    # shade_factor = 0 to 0.1 default : 0.02
    res = cv2.resize(img, dsize=(w//2, h//2), interpolation=cv2.INTER_LINEAR)
    gray, color = cv2.pencilSketch(res, sigma_s =20, sigma_r = 0.03, shade_factor=0.02)

    cv2.imshow('gray', gray)
    out.write(cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR))

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break


out.release()
cap.release()
```

# Matrix Webcam
* K-Nearest Neighbor
* cv2.createBackgroundSubtractorKNN : 최근접 이웃 알고리즘
> * 비디오를 녹화하는 부분
> * K-nearest Neighbor 알고리즘을 사용해서 영상의 변화를 확인
> * 카메라 열어서 캡처
> * Morphological Transformations : 형태변환 (노이즈 제거, 표현 하고자 하는 사물의 선명화)

```python
import cv2

cap = cv2.VideoCapture(0)
bg_cap = cv2.VideoCapture('bg/bg3.mp4')

cap_size = (int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))
fourcc = cv2.VideoWriter_fourcc('m','p','4','v')
out = cv2.VideoWriter('output.mp4', fourcc, cap.get(cv2.CAP_PROP_FPS), cap_size)

sub = cv2.createBackgroundSubtractorKNN(history=500, dist2Threshold=100, detectShadows=False)

while(cap.isOpened()):
    ret, frame = cap.read()
    if not ret: break

    bg_ret, bg_frame = bg_cap.read()
    # finished the video go to first frame
    if not bg_ret:
        bg_cap.set(1, 0)
        _, bg_frame = bg_cap.read()

    bg_frame = cv2.resize(bg_frame, dsize=cap_size)

    mask = sub.apply(frame)

    # 5*5 circular
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    # morphology images noise erased from the background
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    # morphology images noise erased from the background
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
    mask = cv2.dilate(mask, kernel, iterations=2)

    result = cv2.bitwise_and(bg_frame, frame, mask=mask)
    cv2.imshow('result', result)
    out.write(result)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

out.release()
cap.release()
bg_cap.release()

```





































