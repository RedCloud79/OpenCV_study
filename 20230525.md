# 이미지 연산

* cv2.add(src1, src2, dest, mask, dtype) : src1과 src2 더하기
    * src1 : 첫 번째 입력 이미지
    * src2 : 두 번쨰 입력 이미지
    * dest(optional) : 출력 영상
    * mask(optional) : mask 값이 0이 아닌 픽셀만 연산
    * dtype(optional) : 출력 데이터 타입(dtype)
* cv2.subtract(src1, src2, dest, mask, dtype) : src1에서 src2 빼기
    * 모든 파라미터는 cv2.add()와 동일
* cv2.multiply(src1, src2, dest, scale, dtype) : src1과 src2 곱하기
    * scale(optional) : 연산 결과에 추가 연산할 값
* cv2.divide(src1, src2, dest, scale, dtype) : src1을 src2로 나누기
    * 모든 파라미터는 cv2.multiply()와 동일

* 255를 초과하는 경우 예를 들어서 200 + 100 = 300인 경우, 300-255-1 = 44로 치환을 한다 unit8타입의 값의 범위는 0 ~ 255이므로 255를 넘는 값은 다시 0부터 카운팅을 하기 때문이다.
* cv2.add() 함수를 활용하면 255를 초과하는 모든 값은 255로 반환한다. OpenCV에서는 0보다 작은 모든 값을 0으로 반환 한다.
* 곱하기와 나누기 연산도 255를 초과하거나 0보다 작은 값을 갖지 않고, 소수점은 갖지 않는다.

#### 이미지 합성
* numpy의 합이나 cv2.add() 함수만으로는 좋은 결과를 얻을 수 없다. 그 이유는 numpyt 합 연산을 수행하면 픽셀 값이 255가 넘는 경우 초과 값만을 갖기 때문에 이미지가 검은색에 가깝게 된다. cv2.add() 연산을 하면 대부분의 픽셀 값이 255 가까이 몰리는 현상이 발생하여 영상이 전체적으로 하얗게 된다.
* 두 이미지를 제대로 합성하려면 각각의 이미지에 가중치를 주고 합해야 한다.
    * cv2.addWeight(img1, alpha, img2, beta, gamma)
        * img1, img2 : 합성할 두 이미지
        * alpha : img1에 지정할 가중치(알파 값)
        * beta : img2에 지정할 가중치, 흔히 (1-alpha) 적용
        * gamma : 연산 결과에 가감할 상수, 흔히 0 적용

```python
import cv2
import numpy as np

alpha = 0.5 # 합성에 사용할 알파 값

#---① 합성에 사용할 영상 읽기
img1 = cv2.imread('../img/wing_wall.jpg')
img2 = cv2.imread('../img/yate.jpg')

# ---② NumPy 배열에 수식을 직접 연산해서 알파 블렌딩 적용
blended = img1 * alpha + img2 * (1-alpha)
blended = blended.astype(np.uint8) # 소수점 발생을 제거하기 위함
cv2.imshow('img1 * alpha + img2 * (1-alpha)', blended)

# ---③ addWeighted() 함수로 알파 블렌딩 적용
dst = cv2.addWeighted(img1, alpha, img2, (1-alpha), 0) 
cv2.imshow('cv2.addWeighted', dst)

cv2.waitKey(0)
cv2.destroyAllWindows()
```
> * 트렉바를 활용하여 알파를 조정하여 두개의 사진의 합성의 정도를 조절을 할 수도 있다.

#### 비트와이즈 연산
* OpenCV를 활용하여 두 이미지의 비트 단위 연산을 할 수도 있다.
* 비트와이즈 연산은 두 이미지를 합성할 때 특정 영역만 선택하거나 특정 영역만 제외하는 등의 선별적인 연산에 도움이 된다.

* OpenCV에서 제공하는 비트와이즈 연산 함수
    * cv2.bitwise_and(img1, img2, mask=None) : 각 픽셀에 대해 AND 연산
    * cv2.bitwise_or(img1, img2, mask=None) : 각 픽셀에 대해 OR 연산
    * cv2.bitwise_xor(img1, img2, mask=None) : 각 픽셀에 대해 XOR 연산
    * cv2.bitwise_not(img1, igm2, mask=None) : 각 픽셀에 대해 NOT 연산
* img1, img2는 연산을 할 이미지이며, 두 이미지는 동일한 shape를 가져야 한다. mask는 0이 아닌 픽셀만 연산하게 한다.

```python
import numpy as np, cv2
import matplotlib.pylab as plt

#--① 이미지 읽기
img = cv2.imread('../img/girl.jpg')

#--② 마스크 만들기
mask = np.zeros_like(img)
cv2.circle(mask, (150,140), 100, (255,255,255), -1)
#cv2.circle(대상이미지, (원점x, 원점y), 반지름, (색상), 채우기)

#--③ 마스킹
masked = cv2.bitwise_and(img, mask)

#--④ 결과 출력
cv2.imshow('original', img)
cv2.imshow('mask', mask)
cv2.imshow('masked', masked)
cv2.waitKey()
cv2.destroyAllWindows()
```
> * 이미지의 일부분을 원하는 모양으로 떼어내는 예제 코드이다.
> * 원본 이미지와 원 이미지를 AND 연산하면 100의 반지름을 가진 원안에 원본 이미지가 들어가있는 형태를 가지게 된다.
> * AND 연산은 Ture(0이 아닌 값)와 Ture(0이 아닌 값)이 합처진 부분만 True가 출력되기 때문이다.

#### 이미지 합성과 마스킹











