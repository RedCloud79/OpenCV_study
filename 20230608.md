# 스케치 효과와 특정 색상 출력

```python
import cv2
import pafy
from cap_from_youtube import cap_from_youtube
import numpy as np

def toPencilSketch(origin:cv2.Mat) -> cv2.Mat:
    out = origin.copy()
    out = cv2.GaussianBlur(out, ksize=(9,9), sigmaX=0)
    out, color = cv2.pencilSketch(out, sigma_s=20, sigma_r=0.03, shade_factor=0.02)
    return out

def trackingColor(origin:cv2.Mat) -> cv2.Mat:
    frame = origin.copy()

    bgGray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    frameHSV = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

    lower_red = np.array([0, 120, 70])
    upper_red = np.array([10, 255, 255])
    mask1 = cv2.inRange(frameHSV, lower_red, upper_red)

    lower_red = np.array([130, 120, 70])
    upper_red = np.array([180, 255, 255])
    mask2 = cv2.inRange(frameHSV, lower_red, upper_red)

    mask = mask1 + mask2
    redFrame = cv2.bitwise_and(frame, frame, mask=mask)
    # maskBGR = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)
    # redFrame = cv2.bitwise_and(frame, mask)
    bgGray = cv2.cvtColor(out_1, cv2.COLOR_GRAY2BGR)
    out = cv2.bitwise_or(bgGray, redFrame)
    return out

url = 'https://www.youtube.com/watch?v=QyBdhdz7XM4'

cap = cap_from_youtube(url, '480p')

if cap.isOpened():

    while True:
        ret, frame = cap.read()
        if not ret: break
        out_1 = toPencilSketch(frame)

        out_2 = trackingColor(frame)

        cv2.imshow('video', out_2)
        if cv2.waitKey(25) >= 0: break

    pass
cap.release()
cv2.destroyAllWindows()
```

# 이미지 이동, 확대/축소, 회전

* dst = cv2.warpAffine(src, matrix, dsize, dst, flags, borderMode, borderValue)
    * src: 원본 이미지, numpy 배열
    * matrix: 2 x 3 변환행렬, dtype=float32
    * dsize: 결과 이미지의 크기, (width, height)
    * flags(optional): 보간법 알고리즘 플래그
    * borderMode(optional): 외곽 영역 보정 플래그
    * borderValue(optional): cv2.BORDER_CONSTANT 외곽 영역 보정 플래그일 경우 사용할 색상 값 (default=0)
    * dst: 결과 이미지
        * 보간법 : 화소와 화소 사이의 비어있는 공간을 어떠한 방식으로 보정할 것인가.
        * 

> * flags의 값
>   > cv2.INTER_LINEAR: default 값, 인접한 4개 픽셀 값에 거리 가중치 사용   
>   > cv2.INTER_NEAREST: 가장 가까운 픽셀 값 사용   
>   > cv2.INTER_AREA: 픽셀 영역 관계를 이용한 재샘플링   
>   > cv2.INTER_CUBIC: 인정합 16개 픽셀 값에 거리 가중치 사용   

> * borderMode의 값
>   > cv2.BORDER_CONSTANT: 고정 색상 값   
>   > cv2.BORDER_REPLICATE: 가장자리 복제   
>   > cv2.BORDER_WRAP: 반복   
>   > cv2.BORDER_REFLECT: 반사   

```python
import cv2
import numpy as np

img = cv2.imread('./res/apple.jpg')
height, width = img.shape[:2]

# array, list
# 다수의 자료를 포함, 순서가 있고 시작이 0번, 인덱스가 숫자형식의 번호로 구성
#        0,1,2,3,4,5,6,7.....
# arr = [1,2,3,4,5,6,7,7], 원소의 자료형이 모두 같아야한다
# arr[0], arr[1], arr[2], arr[3]

smallFactor = 0.5
bigFactor = 2
# 1. 0.5배 축소 변환 행렬
m_small = np.float32([[smallFactor, 0, 0], [0, smallFactor, 0]])
m_big = np.float32([[bigFactor, 0, 0], [0, bigFactor, 0]])

small_dsize = (int(height*smallFactor), int(width*smallFactor))
dst1 = cv2.warpAffine(img, m_small, small_dsize)

big_dsize = (int(height*bigFactor), int(width*bigFactor))
dst2 = cv2.warpAffine(img, m_big, big_dsize)

dst4 = cv2.warpAffine(img, m_small, small_dsize, None, cv2.INTER_AREA)
dst5 = cv2.warpAffine(img, m_big, big_dsize, None, cv2.INTER_CUBIC)


cv2.imshow('original', img)
# cv2.imshow('small', dst1)
# cv2.imshow('big1', dst2)
# cv2.imshow('big2', dst3)
cv2.imshow('big4', dst4)
cv2.imshow('big5', dst5)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 회전

```python
import cv2
import numpy as np

img = cv2.imread('./res/apple.jpg')
rows, cols = img.shape[0:2]

# 라디안 각도 계산(60진법을 호도법으로 변경)
d45 = 45.0 * np.pi / 180
d90 = 90.0 * np.pi / 180

# 회전을 위한 변환 행렬 생성
m45 = np.float32( [[np.cos(d45), -1* np.sin(d45), rows//2],
                   [np.sin(d45), np.cos(d45), -1*cols//4]])
m90 = np.float32( [[np.cos(d90), -1* np.sin(d90), rows],
                   [np.sin(d90), np.cos(d90), 0]])

# 회전 변환 행렬 적용
r45 = cv2.warpAffine(img, m45, (cols, rows))
r90 = cv2.warpAffine(img, m90, (rows, cols))

cv2.imshow('original', img)
cv2.imshow('45', r45)
cv2.imshow('90', r90)
cv2.waitKey(0)
cv2.destroyAllWindows()
```






