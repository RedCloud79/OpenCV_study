# ROS를 활용한 하드웨어간 통신

## ROS 설치
> 1. (https://wiki.ros.org) 로 접속
> 2. install -> ROS Noetic Ninjemys -> Ubuntu -> 위에서 부터 순차 진행
> 3. 1.2, 1.3, 1.4 맨윗줄, 1.4 Desktop-Full install 을 순차적으로 터미널에 입력하여 다운로드
> 4. 1.5 Environment setup의 source와 bash를 진행해준다.
> 5. 1.6 Dependencies for building package를 install 해준다.
> 6. 나머지 아래 3줄을 터미널창에 입력해준다.
> 7. catkin_ws 빌드

## 카메라 통신
> 1. catkin_create_pkg my_cam sensor_msgs cv_bridge rospy 로 패키지 생성
> * rosmsg show sensor_msgs/ (tap, tap) 으로 내부 정보 확인
> * rosmsg show sensor_msgs/Image 로 이미지 메세지 정보 확인
> * bridge가 ros 와 opencv의 연결 역할을 해준다.
> 2. scripts 폴더을 생성하고, my_cam_pub.py 파일 생성

```python
#!/usr/bin/python
#!-*- coding: utf-8 -*-

import rospy
import cv2
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError

rospy.init_node('my_cam_pub') # 노드를 지정
cap = cv2.VideoCapture(0) # 카메라 연결

if cap.IsOpened():
    pub = rospy.Publisher('my_image', Image, queue_size=10)
    bridge = CvBridge() # cv_bridge로 ros와 opencv의 데이터 변환에 사용된다.

    fps = cap.get(cv2.CAP_PROP_FPS)
    loop_rate = rospy.Rate(fps)

    while not rospy.is_shutdown():
        ret, frame = cap.read()
        if not ret:
            continue
        try:
            msg = bridge.cv2_to_imgmsg(frame, "bgr8") # frame을 img로 변환을 시켜준다. bgr8의 인코딩 사용
            pub.publish(msg)
        except CvBridgeError as e:
            print(e) # 변환 에러에대한 출력
        loop_rate.sleep()
```

> 3. my_cam_sub.py를 생성

```python
#!/usr/bin/python
#!-*- coding: utf-8 -*-

import rospy
import cv2
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError

bridge = CvBridge()

def imgCallback(msg):
    try:
        frame = bridge.imgmsg_to_cv2(msg, "bgr8")
    except CvBridgeError as e:
        print(e)
    
    cv2.imshow('my_image', frame)
    cv2.waitKey(3)

rospy.init_node('my_cam_sub')
sub = rospy.Subscriber('my_image', Image, imgCallback, queue_size=10)
rospy.spin()
cv2.destroyAllWindows()
```

> 4. CMakeLists.txt의 Install 부분의 catkin_install_python을 추가






















